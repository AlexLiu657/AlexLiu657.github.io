{"meta":{"title":"莫语小栈","subtitle":"欢迎来到莫语小栈","description":"莫语小栈","author":"Alex Liu","url":"https://it65720.top","root":"/"},"pages":[{"title":"","date":"2022-04-17T11:51:34.137Z","updated":"2022-04-17T11:51:34.137Z","comments":true,"path":"404.html","permalink":"https://it65720.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-05-18T15:19:55.284Z","updated":"2022-05-18T15:19:55.284Z","comments":false,"path":"bb/index.html","permalink":"https://it65720.top/bb/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-17T16:41:44.078Z","updated":"2022-05-17T16:41:44.078Z","comments":false,"path":"about/index.html","permalink":"https://it65720.top/about/index.html","excerpt":"","text":"真的就是一个简单的自我介绍🤐，在搭建博客上花了太多时间，反而忽略了最重要的写博客QAQ，首先莫语是一种我对我自己的期望（不是摸鱼哦）,本人有时候做事比较毛躁,给自己起名莫语是希望自己能多思考,多实践,少说话。其次我是南京理工大学泰州科技学院2014级的学生,专业是软件工程,现在在从事软件开发相关的工作，现在主要技术栈是Java相关，前端对Vue，Angular等也有了解，后续准备对自己感兴趣的技术进行了解或者深入学习，同时也会在本站和大家进行分享😉。"},{"title":"所有分类","date":"2022-04-24T17:08:02.247Z","updated":"2022-04-24T17:08:02.247Z","comments":true,"path":"categories/index.html","permalink":"https://it65720.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-17T15:45:43.119Z","updated":"2022-05-17T15:45:43.119Z","comments":true,"path":"friends/index.html","permalink":"https://it65720.top/friends/index.html","excerpt":"走，去见网友","text":"走，去见网友 &nbsp;举个栗子&nbsp;前置要求 &nbsp;本站信息 友链格式，除高亮行必填，其余均可选填~- title: # 网站名称 url: # 访问地址 avatar: # 头像地址 description: # 描述/一句话概述/格言 screenshot: # 网站截图/展示图 backgroundColor: # 头像背景颜色 textColor: # 文本颜色 keywords: - 标签一 - 标签二 Https 站点（大势所趋） 网站加载速度正常（待定…） 免费类域名站点请略过（潜在的不可靠性） 新创站点请略过（建议拥有一定的原创内容） 不接受一切商业性或强烈侵入类广告之站点 不接受违反中华人民共和国法律法规之站点 访问地址：https://it65720.top 站点名称：莫语小栈 头像地址：https://bu.dusays.com/2022/04/19/98c06d5e34ebc.png 描述信息：望永不停止思考"},{"title":"所有标签","date":"2022-04-24T15:50:03.014Z","updated":"2022-04-24T15:50:03.014Z","comments":true,"path":"tags/index.html","permalink":"https://it65720.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-17T16:08:32.178Z","updated":"2022-05-17T16:08:32.178Z","comments":false,"path":"protocol/comment/index.html","permalink":"https://it65720.top/protocol/comment/index.html","excerpt":"","text":"评论服务协议 用户发言前，请认真阅读本条例。一经发言，即视为同意接受本条例；如不同意，请勿发言。 一、制定本管理办法的目的在于为用户提供文明、理性、友善、高质量的信息分享和公共讨论的网络交流空间。本网站所称的评论服务，是指通过运营网络互动传播技术平台，供用户对本网站传播的各类信息发表评论意见（包括但不限于语音、文字、图片、音频、视频等信息）的服务。 二、用户使用评论服务，不得逾越法律法规、社会主义制度、国家利益、公民合法权益、社会公共秩序、道德风尚和信息真实性“七条底线”；应尊重其他用户合法权益及公民个人隐私，尊重社会公序良俗，遵守国家法律法规。上文提及的国家法律法规，包括但不限于：《全国人民代表大会常务委员会关于维护互联网安全的决定》、《全国人民代表大会常务委员会关于加强网络信息保护的决定》、《最高人民法院最高人民检察院关于办理利用信息网络实施诽谤等刑事案件适用法律若干问题的解释》、《互联网信息服务管理办法》、《互联网新闻信息服务管理规定》以及《未成年人保护法》等。 三、用户应当按照规定使用真实信息使用本网站的评论服务。对注册用户发表的评论，本网站保留相应的管理权利。 四、用户在发表言论时，不得含有以下内容： ​ (一) 反对宪法确定的基本原则的； ​ (二) 危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的； ​ (三) 损害国家荣誉和利益的； ​ (四) 煽动民族仇恨、民族歧视，破坏民族团结的； ​ (五) 煽动地域歧视、地域仇恨的； ​ (六) 煽动非法集会、结社、游行、示威、聚众扰乱社会秩序的； ​ (七) 破坏国家宗教政策，宣扬邪教和迷信的； ​ (八) 侮辱和歧视性别、年龄、种族、出身、国别、性取向、生理缺陷的； ​ (九) 散布谣言，扰乱社会秩序、破坏社会稳定的； ​ (十) 散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的； ​ (十一) 侮辱或诽谤他人，侵害他人合法权益的； ​ (十二) 对他人进行暴力恐吓、威胁，实施人肉搜索的； ​ (十三) 未获得未满18周岁未成年人法定监护人的书面同意，传播该未成年人的隐私信息的； ​ (十四) 散布污言秽语，损坏社会公序良俗的； ​ (十五) 侵犯他人知识产权的； ​ (十六) 散布非法商业广告，或类似的商业招揽信息； ​ (十七) 使用本网站常用语言文字以外的其他语言文字评论的； ​ (十八) 与所评论的信息毫无关系的； ​ (十九) 所发表的信息毫无意义的，或刻意使用字符组合以逃避技术审核的； ​ (二十) 法律、法规和规章禁止传播的其他信息。 五、对违反上述承诺的用户，我们有权拒绝发布、删除评论、短期禁止发言直至永久关闭注册账号等管理措施。 六、若用户违反承诺、发布侵害第三人合法权益的信息而导致本网站被判决向被侵权人赔偿，我们保留依法向该用户追偿的权利。 七、本网站承诺，完善公众举报平台，欢迎用户监督举报各类不法传播活动和违法有害信息，以共同维护文明、有价值的评论环境，营造清朗的网络空间。"},{"title":"","date":"2022-05-17T16:18:03.001Z","updated":"2022-05-17T16:18:03.001Z","comments":false,"path":"protocol/copyright/index.html","permalink":"https://it65720.top/protocol/copyright/index.html","excerpt":"","text":"版权协议 本站所有原创文章采用 CC BY-NC-SA 4.0 许可协议 创作人允许他人对自己享有著作权的作品或演绎作品进行转载、节选、混编、二次创作，但不得用于商业目的，且使用时须署名，须采用与本创作相同的协议进行授权。"}],"posts":[{"title":"hahah","slug":"test11 copy","date":"2022-05-24T12:07:23.174Z","updated":"2022-06-07T01:04:41.562Z","comments":true,"path":"/2022052495b172e3.html","link":"","permalink":"https://it65720.top/2022052495b172e3.html","excerpt":"","text":"在上一篇文章中，用了很大的篇幅介绍了MyBatis的配置，并且再最后进行了简单的CRUD操作，这篇文章按照点的方式来介绍一下MyBatis那些有别于JDBC的用法。 一、Mapper代理模式在基础的应用中使用SqlSession传值statementId(Mapper文件的namespace+对应映射语句的id)实现对数据库的访问，其中的statementId硬编码在代码中，在开发的过程中我们随时随地需要关注这些硬编码的地方，使用Mapper代理的方式可以是我们的开发的注意点放在书写SQL和接口的编写上，接口实现对象由mybatis自动生成代理对象。具体实现还需要满足MyBatis的约定： mapper.xml映射文件中namespace指定为mapper接口的全限定名，此步骤目的：通过mapper.xml和mapper.java进行关联 mapper.xml中statement的id就是mapper.java中方法名 mapper.xml中statement的parameterType和mapper.java中方法输入参数类型一致 mapper.xml中statement的resultType和mapper.java中方法返回值类型一致具体代码如下： （1）创建一个Mapper接口 UserMapper.xml1234567package com.alex.mapper;import com.alex.pojo.User;import java.util.List;public interface IUserMapper &#123; public List&lt;User&gt; findAll(); public User findUserById(Integer id);&#125; （2）修改（新建）mapper.xml，注意修改namespace12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.alex.mapper.IUserMapper&quot;&gt; &lt;!-- 用户信息ResultMap --&gt; &lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.alex.pojo.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.alex.pojo.User&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据用户编号，查询单个用户实体 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE id = #&#123;id,javaType=int,jdbcType=NUMERIC&#125; &lt;/select&gt;&lt;/mapper&gt; （3）通过getMapper方法获取Mapper接口代理对象，使用接口中的方法进行数据库访问1234567891011// 省略上面获取sqlSession的代码，可以查看上一篇的代码IUserMapper userMapper = sqlSession.getMapper(IUserMapper.class);List&lt;User&gt; list = userMapper.findAll();for (User user : list) &#123; System.out.println(user);&#125;User user = userMapper.findUserById(1);System.out.println(user);System.out.println(&quot;---------------------&quot;);User user = userMapper.findUserById(1);System.out.println(user); 上面的Mapper对象是MyBatis生产出的代理对象,具体可以看下图 代理对象 在上面的配置中一定要遵守上面的四条约定，特别要注意的是namespace不可以使用别名 在实际的使用中一般都会使用Mapper代理模式，后续所有的介绍都将基于这种开发模式进行 二、如何传入多个参数在上面findUserById方法中，传入了一个Integer类型的id进行查询，实际使用中可能会传入多个参数，MyBatis主要提供了以下四种方式实现 1、使用map接口传入参数public List&lt;User&gt; findUserByMap(Map&lt;String, Object&gt; parameterMap); &lt;select id=&quot;findUserByMap&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt; select * from user where username =#&#123;username&#125; and password = #&#123;password&#125;&lt;/select&gt; map适用几乎所有场景，但是map是一个键值对应的集合，使用者要通过阅读它的键，才能明了其作用；其次，使用map不能限定其传递的数据类型，因此业务性质不强，可读性差，使用者要读懂代码才能知道需要传递什么参数给它。 2、使用注解参数传入参数public List&lt;User&gt; findUserByAnnotation(@Param(&quot;userName&quot;) String username, @Param(&quot;password&quot;) String password); &lt;select id=&quot;findUserByAnnotation&quot; resultType=&quot;User&quot;&gt; select * from user where username =#&#123;userName&#125; and password = #&#123;password&#125;&lt;/select&gt; MyBatis提供了一个注解@Paramorg.apache.ibatis.annotations.Param，可以通过它去定义映射器的参数名称，使用它可以得到更好的可读性,此时并不需要给出parameterType属性，但是这会带来一个麻烦。如果SQL很复杂，拥有大于10个参数，那么接口方法的参数个数就多了，使用起来就很不容易，这个时候就需要实体类、Java Bean的方法进行传递了。 3、使用Java Bean传入参数public List&lt;User&gt; findUserByBean(User userParam); &lt;select id=&quot;findUserByBean&quot; parameterType=&quot;com.alex.pojo.User&quot; resultType=&quot;User&quot;&gt; select * from user where username =#&#123;username&#125; and password = #&#123;password&#125;&lt;/select&gt; 4、混合使用@Param注解后面除了基础数据类型和Java内置类型以外，还可以传入自定义的实体类、Java Bean。 public List&lt;User&gt; findByMix(@Param(&quot;params&quot;) User userParam); &lt;select id=&quot;findByMix&quot; resultType=&quot;User&quot;&gt; select * from user where username =#&#123;params.username&#125; and password = #&#123;params.password&#125;&lt;/select&gt; 以上是四种传参的方式，可以根据实际情况进行选取。 三、如何记录SQL查询日志目前的配置下，MyBatis执行SQL时不会将运行日志输出在控制台或者写在日志中，在后续的使用中需要看一下SQL查询的过程，所以我们需要通过配置使用MyBatis日志功能。在讲MyBatis的主配置文件中，有一个settings属性设置有一个配置项logImpl，这个里面可配置的有SLF4J|LOG4J|LOG4J2|JDK_LOGGING|COMMONS_LOGGING|STDOUT_LOGGING|NO_LOGGING，下面介绍两种方式进行日志的输出。 1、STDOUT_LOGGINGMyBatis主配置文件&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;&lt;/settings&gt; 运行日志控制台截图1 这种方式不太好的地方, 就是还是作为控制台输出的System.out.println, 无法使用我们的日志配置格式, 也没有刷到日志文件中，Debug调试还可以，但是在生产中建议结合日志框架进行操作。 2、SLF4J(1)pom.xml引入slf4j的jar包12345678910&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt;&lt;/dependency&gt; (2)修改MyBatis主配置文件123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot; /&gt;&lt;/settings&gt; (3)在项目中创建log4j.properties123456789101112131415161718192021#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/alex.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sq1.PreparedStatement=DEBUG 运行日志控制台截图2 运行日志文件截图 文章中暂时使用STDOUT_LOGGING进行日志的输出 四、#{}和${}的区别在上面的例子中使用#{}代替参数，其实还可以是使用${}来代替参数。#{} 是预编译处理。${} 就是字符串替换。直接替换掉占位符。$方式一般用于传入数据库对象，例如传入表名。使用 ${} 的话会导致 sql 注入。什么是 SQL 注入呢？比如 select * from user where id &#x3D; ${id}这里的id应该是一个数值。然后如果对方传过来的是 001 and name &#x3D; tom。就相当于多加了一个条件。或者把SQL语句直接写进来了，001;drop table user，就直接把表给删了！！！所以为了防止 SQL 注入，能用 #{} 的不要去用${} 如果非要用 ${} 的话，那要注意防止 SQL 注入问题，可以手动判定传入的变量，进行过滤，一般 SQL 注入会输入很长的一条 SQL 语句 ${}运行的日志 ${}运行的日志 #{}运行的日志 #{}运行的日志 这里使用的findUserById按照之前的写法改成${}会报错org.apache.ibatis.reflection.ReflectionException: There is no getter for property named id in class java.lang.Integer,因为MyBatis在解析的时候把parameterType&#x3D;int解析成包装类java.lang.Integer，在Integer中不存在id属性，可以使用上面的@Param注解,如下 public User findUserById(@Param(&quot;id&quot;) Integer id); 五、如何在SQL中写一个like日常使用中常常会使用like来做模糊查询，在普通的JDBC中通常使用拼接的方式来传递参数，MyBatis下有五种方式来进行like的拼接。首先我们先在Mapper对应的Java中定义一个方法 public List&lt;User&gt; findUserByLike(@Param(&quot;username&quot;) String username); 1、使用${}进行拼接123&lt;select id=&quot;findUserByLike&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE username LIKE &#x27;%$&#123;username&#125;%&#x27;&lt;/select&gt; 这种方式简单，但是无法防止SQL注入，所以不推荐使用 2、使用#{}进行拼接123&lt;select id=&quot;findUserByLike&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE username LIKE &quot;%&quot;#&#123;username&#125;&quot;%&quot;&lt;/select&gt; 3、使用CONCAT进行字符串拼接123&lt;select id=&quot;findUserByLike&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE username LIKE CONCAT(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;)&lt;/select&gt; 4、使用bind标签1234&lt;select id=&quot;findUserByLike&quot; resultMap=&quot;userResultMap&quot;&gt; &lt;bind name=&quot;pattern1&quot; value=&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot; /&gt; SELECT * FROM user WHERE username LIKE #&#123;pattern1&#125;&lt;/select&gt; 这里使用的bind标签是后面要讲的动态SQL的一员，主要的作用可以在OGNL表达式中创建一个变量并将其绑定到上下文，换句话说建立新的映射关系，对变量进行操作（比如拼接，拼接可以替换CONCAT） 5、在调用传值时处理进行拼接123&lt;select id=&quot;findUserByLike&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE username LIKE #&#123;username&#125;&lt;/select&gt; 调用时传值1List&lt;User&gt; list = userMapper.findUserByLike(&quot;%al%&quot;); 六、动态SQL在实际开发过程中，在需要条件动态拼接的时候会非常痛苦，有时候为了保证SQL的正确性，需要拼接where 1&#x3D;1进行填充；有时候面对动态的参数时还可能会存在SQL注入的问题。MyBatis提供了一些标签实现动态SQL来解决这些问题。 1、if标签1public List&lt;User&gt; findUserByIf(@Param(&quot;user&quot;) User user); 123456789&lt;select id=&quot;findUserByIf&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE 1=1 &lt;if test=&quot;user!=null and user.username==&#x27;alex&#x27; and user.username!=null&quot;&gt; and username LIKE #&#123;user.username&#125; &lt;/if&gt; &lt;if test=&quot;user!=null and user.id &amp;lt;= 1&quot;&gt; and id = #&#123;user.id&#125; &lt;/if&gt;&lt;/select&gt; 从上面的可以看到，中写了对传入参数的判断，比如当user传的是null的话，sql将不会拼接在执行的SQL中，当user对象当中username传的不为null和并且为alex的时候才会拼第一段，当id传入的数字小于等于1的时候才会拼接第二段在上面的例子中有两个注意的点（1）在普通的程序中逻辑表达式是&amp;和|，在if中使用and和or进行代替（2）在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的，需要把他们变成转义字符进行使用 符号 原符号 替换符号 小于 &lt; &amp;lt; 小于等于 &lt;&#x3D; &amp;lt;= 大于 &gt; &amp;gt; 大于等于 &gt;&#x3D; &amp;gt;= 不等于 &lt;&gt; &amp;lt;&amp;gt; 与 &amp; &amp;amp; 单引号 ‘ &amp;apos; 双引号 “ &amp;quot; 除了转移字符的形式，还可以使用CDATA区段进行操作 大于等于 &lt;![CDATA[ &gt;= ]]&gt;小于等于 &lt;![CDATA[ &lt;= ]]&gt;不等于&lt;![CDATA[ &lt;&gt; ]]&gt; 2、choose, when, otherwise标签在JAVA程序中，处理使用if做判断，还会使用switch做判断，比如在判断枚举的时候，会根据不通的类型来拼接SQL，这个时候可以使用choose标签 public List&lt;User&gt; findUserByChoose(@Param(&quot;user&quot;) User user); 1234567891011121314&lt;select id=&quot;findUserByChoose&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user where 1=1 &lt;choose&gt; &lt;when test=&quot;user!=null and user.id == 1&quot;&gt; AND id = 6 &lt;/when&gt; &lt;when test=&quot;user!=null and user.id == 2 &quot;&gt; AND id = 5 &lt;/when&gt; &lt;otherwise&gt; AND id = 7 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 上面例子意思是在传入的user对象id为1的时候拼接第一段SQL，如果id为2时候拼接第二段SQL，如果都不满足则拼接第三段SQL，例子可能没有特殊的含义，理解意思即可，用法类似switch。 3、where,trim, set标签在上面的例子中还是存在where 1&#x3D;1的拼接，这个时候就需要结合where标签进行动态的拼接 1234567891011&lt;select id=&quot;findUserByIf&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user &lt;where&gt; &lt;if test=&quot;user!=null and user.username==&#x27;alex&#x27; and user.username!=null&quot;&gt; and username LIKE #&#123;user.username&#125; &lt;/if&gt; &lt;if test=&quot;user!=null and user.id &amp;lt;= 1&quot;&gt; and id = #&#123;user.id&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个标签里面会自动拼接上where 并且把第一个and或者or去掉除了上面的where标签，还可以MyBatis提供的trim标签，代码如下： 1234567891011&lt;select id=&quot;findUserByIf&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND|OR&quot;&gt; &lt;if test=&quot;user!=null and user.username==&#x27;alex&#x27; and user.username!=null&quot;&gt; username LIKE #&#123;user.username&#125; &lt;/if&gt; &lt;if test=&quot;user!=null and user.id &amp;lt;= 1&quot;&gt; or id = #&#123;user.id&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 介绍完了where的情况，在修改的时候会使用set语言，这个时候set的值也需要自动拼接，在最后一个的字段的时候需要把拼接的逗号去掉，这个时候可以使用set标签，代码如下： 123456789&lt;update id=&quot;updateUserByIf&quot;&gt; update user &lt;set&gt; &lt;if test=&quot;user.username != null&quot;&gt;username=#&#123;user.username&#125;,&lt;/if&gt; &lt;if test=&quot;user.password != null&quot;&gt;password=#&#123;user.password&#125;,&lt;/if&gt; &lt;if test=&quot;user.birthday != null&quot;&gt;birthday=#&#123;user.birthday&#125;,&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 同where标签相同，set标签会自动添加set以及去掉最后的逗号同样的，set标签也可以使用trim标签代替，代码如下： 123456789&lt;update id=&quot;updateUserByIf&quot;&gt; update user &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;user.username != null&quot;&gt;username=#&#123;user.username&#125;,&lt;/if&gt; &lt;if test=&quot;user.password != null&quot;&gt;password=#&#123;user.password&#125;,&lt;/if&gt; &lt;if test=&quot;user.birthday != null&quot;&gt;birthday=#&#123;user.birthday&#125;,&lt;/if&gt; &lt;/trim&gt; where id=#&#123;user.id&#125;&lt;/update&gt; 讲了这么多的trim标签，发现他里面有四个主要的属性： prefix :在trim中包含的语句前加上前缀内容 suffix :在trim中包含的语句后加上后缀内容 prefixOverrides:去除对应的前缀 suffixOverrides :去除对应的后缀trim标签在insert中可以使用prefix，suffix，suffixOverrides的结合去掉最后的，并在前后拼接括号。 4、foreach标签有时候参数会传入一个集合或数组进行遍历，通常这种情况发生在IN的拼接和insert的拼接中 public List&lt;User&gt; findUserByForeach(@Param(&quot;usernameList&quot;)List usernameList); 12345678910&lt;select id=&quot;findUserByForeach&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user &lt;where&gt; &lt;foreach collection=&quot;usernameList&quot; open=&quot;username IN (&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;username&quot; index=&quot;i&quot;&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; #&#123;username&#125; &lt;/if&gt; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; in解析的SQL foreach主要的属性有下面几个 collection：入参类型，可以是list、array open：前缀 close：后缀 separator： 循环的部分以此分割 item：集合（数组）子元素的别名。子元素也可以是对象 index：当前子元素的下标。 5、bind标签bind标签在上面的like拼接中使用过，作用是将对应传过来的参数进行拼接成新的参数进行使用。 1234&lt;select id=&quot;findUserByLike&quot; resultMap=&quot;userResultMap&quot;&gt; &lt;bind name=&quot;pattern1&quot; value=&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot; /&gt; SELECT * FROM user WHERE username LIKE #&#123;pattern1&#125;&lt;/select&gt; 6、sql标签在上面的所有SQL语句中，我们都有一句共同的SELECT * FROM user，当然正式使用肯定不能用*，一般都会使用字段名，但是字段名多的话会有很多的重复性，这个时候就可以把公共的SQL提出到sql标签中，后面在使用的地方进行引用。 定义sql标签123&lt;sql id=&quot;selectSql&quot;&gt; select * from user&lt;/sql&gt; 使用include标签进行引用123&lt;select id=&quot;findUserById&quot; resultMap=&quot;userResultMap&quot;&gt; &lt;include refid=&quot;selectSql&quot; /&gt; WHERE id = $&#123;id&#125;&lt;/select&gt; sql标签也支持多数据库厂商操作，可以使用databaseId进行配置。 七、如何获得数据库的自增主键数据库的自增主键主要分两种，第一种使用数据库的机制自动递增生成主键如Mysql、SQLServer等，第二种就是使用序列机制手动调整序列生成主键如Oracle。 1、MysqL获取自增主键Mysql这种可以自动生成主键的可以使用useGeneratedKeys=&#39;true&#39;表明使用自增主键获取主键值策略,然后再用keyProperty属性告诉Mybatis生成的主键封装在哪个属性中，用法如下： 1、添加Mapper映射方法1234&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.alex.pojo.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO user(username,password,birthday) VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;); &lt;/insert&gt; 2、定义Java方法1public void insertUser(User user); 3、调用方法123456User userInfo = new User();userInfo.setUsername(&quot;lalala&quot;);userInfo.setPassword(&quot;123456&quot;);userInfo.setBirthday(&quot;2022-05-01&quot;);userMapper.insertUser(userInfo);System.out.println(userInfo); 自动生成主键会写到对象中 2、Oracle获取自增主键Oracle并不支持自增，但可以使用序列来模拟自增，每次插入的数据的主键是从序列中拿到的值，可以使用selectKey实现序列值的添加并写到主键中，用法如下： 1234567&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.alex.pojo.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;Integer&quot;&gt; select USER_SEQ.nextval from dual &lt;/selectKey&gt; insert into tb_user (id, username,password,birthday) values (#&#123;id&#125;, #&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;)&lt;/insert&gt; 或者还可以直接调用SQL在序列中直接拼接 1234567&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.alex.pojo.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;Integer&quot;&gt; select USER_SEQ.currval from dual &lt;/selectKey&gt; insert into tb_user (id, username,password,birthday) values (USER_SEQ.nextval, #&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;)&lt;/insert&gt; 这个里面出现的selectKey中主要的属性有三个： keyProperty：生成的主键封装在哪个属性中 order：当order为BEFORE时，selectKey中的SQL在插入SQL之前运行 当order为AFTER时，当前 SQL 在插入 SQL 之后运行 resultType：生成主键的返回类型所以上面两种方式在思想上有点区别BEFORE 运行顺序：先执行selectKey执行序列查询下一个id的SQL，查出id值封装给id属性。再运行插入的 SQL，就可以取出 id 属性的值。AFTER 运行顺序：先运行插入的SQL（从序列中取出新值作为 id），再运行selectKey查询当前序列位置的SQL，查出id值封装给JavaBean的id属性。 八、如何完成分页查询不多说（主要不知道说啥了，懂的都懂(&#x2F;ω＼)）如题，直接上方法： 1、使用原生sql使用原生的sql来解决分页的问题，比如Mysql使用limit，Oracle中使用rownum来实现数据的分页查询，这种方式需要考虑怎么把分页的参数传入即可。 2、使用RowBoundsRowBounds是MyBatis提供的逻辑分页工具类，RowBounds中有2个字段offset和limit。这种方式获取所有的ResultSet，从ResultSet中的offset位置开始获取limit个记录。 1、添加Mapper映射方法123&lt;select id=&quot;selectPage&quot; resultType=&quot;com.alex.pojo.User&quot;&gt; select * from user&lt;/select&gt; 2、定义Java方法1public List&lt;User&gt; selectPage(RowBounds rowBounds); 3、调用方法12345List&lt;User&gt; list = userMapper.selectPage(new RowBounds(3, 2));System.out.println(&quot;-----------分页的数据----------&quot;);for (User user : list) &#123; System.out.println(&quot;分页的数据&quot;+user);&#125; 在上面讲到，RowBounds是一种物理分页的方式，那么和他相对的时逻辑分页，他们的区别是： 逻辑分页是利用数据库的特性进行分页，例如利用oracle的rownum，mysql的limit，sql server的top，利用这些关键字每次返回部分数据，即分页的结果，由于物理分页每次都会重新访问数据库，可用于数据量大，数据更新频繁的场景。 物理分页是使用利用游标分页，对于所有的数据库都统一操作，使用RowBounds对象即可，但是他需要把数据全部查到内存中进行处理，数据量小了还好进行处理，一旦数据量变大，对内存将会是很大的压力。 九、如何实现一对多的查询十、缓存机制十一、Spring整合十二、Mybatis代码生成","categories":[{"name":"分类6","slug":"分类6","permalink":"https://it65720.top/categories/%E5%88%86%E7%B1%BB6/"}],"tags":[{"name":"测试11","slug":"测试11","permalink":"https://it65720.top/tags/%E6%B5%8B%E8%AF%9511/"},{"name":"测试10","slug":"测试10","permalink":"https://it65720.top/tags/%E6%B5%8B%E8%AF%9510/"}]},{"title":"12312312312qdasfafafasfaef","slug":"test11","date":"2022-05-17T02:55:00.000Z","updated":"2022-05-25T14:14:17.550Z","comments":true,"path":"/202205171260b55f.html","link":"","permalink":"https://it65720.top/202205171260b55f.html","excerpt":"","text":"MyBatis作为一个优秀的持久层框架，目前在我的大多数日常学习和工作中被用来当作数据库Java访问数据库的一种方式，就像《塞尔达传说：旷野之息》之于NS的护航大作一样，我开篇博文准备写一下我所知的MyBatis，做一次学习笔记。😄 一、MyBatis初体验1.创建测试数据库下面是文章中的使用到的建表语句，本文采用的数据库是Mysql 8.0.27 1234567891011DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `birthday` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;INSERT INTO `user` VALUES (&#x27;1&#x27;, &#x27;alex&#x27;, &#x27;123&#x27;, &#x27;2019-12-12&#x27;);INSERT INTO `user` VALUES (&#x27;2&#x27;, &#x27;it65720&#x27;,&#x27;123&#x27;, &#x27;2019-12-12&#x27;); 2.导入依赖本文使用Maven进行构建 Mavenjar包pom.xml12345678910111213 &lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt; &lt;!--mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;MyBatis的jar包下载：https://github.com/mybatis/mybatis-3/releasesMySQL数据库驱动下载：https://dev.mysql.com/downloads/connector/j/ 3.创建表对应的实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.alex.pojo;public class User &#123; private Integer id; private String username; private String password; private String birthday; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, birthday=&#x27;&quot; + birthday + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 4.创建mybatis-config.xml主配置文件和数据库配置文件mybatis-config.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 引入外部资源文件--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 数据库事务管理类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 数据源，type=pooled 说明是使用连接池方式，可以节省资源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 调用资源文件里的用户信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; jdbc.properties1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://192.168.56.103:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=root 5.创建XML映射文件UserMapper.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;User&quot;&gt; &lt;!--查询用户--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.alex.pojo.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 6.编写main方法进行测试12345678910public static void main(String[] args) throws IOException &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; list = sqlSession.selectList(&quot;User.findAll&quot;); for (User user : list) &#123; System.out.println(user); &#125;&#125; demo目录结构 demo运行结果 上面的demo运行结束后，MyBatis将返回的结果集自动转换成对应的实体类，我理解的这个就是ORM（对象关系映射），但是上面的操作只是一个进行简单的MyBatis的配置的小例子，距离真正的实践还差很多，下面先来分析重要的配置文件之一，在测试代码段里面加载的文件mybatis-config.xml。 二、MyBatis的主配置文件MyBatis的配置文件包含了会影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： properties settings typeAliases typeHandlers objectFactory plugins environments environment transactionManager dataSource databaseIdProvider mappers MyBatis中的配置，不但有类型限制，还有顺序限制，必须按照上面树状结构的顺序进行配置。 1.properties（属性）标签中的数据可以在配置文件其他地方进行使用，使用${}可以获取对应的值，有两种配置的方式第一种就是在上面使用外部properties文件进行提供数据，第二种就是在properties中添加property子标签进行配置。 123456789&lt;!-- 引入外部资源文件--&gt;&lt;!--&lt;properties resource=&quot;jdbc.properties&quot;/&gt;--&gt;&lt;properties&gt; &lt;!-- property里面的属性全局均可使用 --&gt; &lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbc.url&quot; value=&quot;jdbc:mysql://192.168.56.103:3306/mybatis&quot;/&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt; 2.settings（设置）settings配置影响MyBatiis框架在运行时的一些行为。settings配置缓存、延迟加载、结果集控制、执行器、分页设置、命名规则等一系列控制性参数。所有的setting配置都被包裹在settings标签对中。 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true&#x2F;false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true&#x2F;false false aggressiveLazyLoading 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。 true&#x2F;false false multipleResultSetsEnabled 是否允许单个语句返回多结果集（需要数据库驱动支持）。 true&#x2F;false true useColumnLabel 使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。 true&#x2F;false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby） true&#x2F;false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONEPARTIALFULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出警告日志（’org.apache.ibatis.session.AutoMappingUnknownColumnBehavior’ 的日志等级必须设置为 WARN）FAILING: 映射失败 (抛出 SqlSessionException) NONEWARNINGFAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。 SIMPLEREUSEBATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定数据库驱动等待数据库响应的秒数。 任意正整数 未设置 (null) defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。 任意正整数 未设置 (null) defaultResultSetType 指定语句默认的滚动策略。（新增于 3.5.2） FORWARD_ONLYSCROLL_SENSITIVESCROLL_INSENSITIVEDEFAULT（等同于未设置） 未设置 (null) safeRowBoundsEnabled 是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 true&#x2F;false False safeResultHandlerEnabled 是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。 true&#x2F;false True mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true&#x2F;false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 SESSIONSTATEMENT SESSION jdbcTypeForNull 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定对象的哪些方法触发一次延迟加载。 用逗号分隔的方法列表。 equals,clone,hashCode,toString defaultScriptingLanguage 指定动态 SQL 生成使用的默认脚本语言。 一个类型别名或全限定类名。 org.apache.ibatis.scripting.xmltags.XMLLanguageDriver defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） 一个类型别名或全限定类名。 org.apache.ibatis.type.EnumTypeHandler callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 true&#x2F;false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2） true&#x2F;false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 未设置 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4JLOG4J(deprecated since 3.5.9)LOG4J2&#x2F;DK_LOGGINGCOMMONS_LOGGING STDOUT_LOGGINGNO_LOGGING 未设置 proxyFactory 指定 Mybatis 创建可延迟加载对象所用到的代理工具。 CGLIB&#x2F; JAVASSIST JAVASSIST （MyBatis 3.3 以上） vfsImpl 指定 VFS 的实现 自定义 VFS 的实现的类全限定名，以逗号分隔。 未设置 useActualParamName 允许使用方法签名中的名称作为语句参数名称。为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） true&#x2F;false true configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） 一个类型别名或完全限定类名。 未设置 settings 的配置项很多，但是真正用到的不会太多，很多都保持了默认，把常用的配置项研究清楚就可以了，比如关于缓存的 cacheEnabled，关于级联的 lazyLoadingEnabled 和 aggressiveLazy Loading，关于自动映射的 autoMappingBehavior 和 mapUnderscoreToCamelCase，关于执行器类型的 defaultExecutorType 等,本文暂时先讲一下基本的配置，后面想开篇深入研究一下Mybatis的缓存机制和级联的延迟加载。 这是一份比较完整的配置1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 3.typeAliases（类型别名）在上面demo中的的UserMapper.xml中配置的resultType为实体类的全类名，但是在使用过程中可以选择别名的方式代替代码中的全类型别名在XML中的配置主要有以下两种方式 对单个类进行起别名对整个包进行起别名123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.alex.pojo.User&quot; alias=&quot;UsEr&quot;&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 映射文件中使用，可以忽略大小写 Mapper.xml12345&lt;!--查询用户--&gt;&lt;select id=&quot;findAll&quot; resultType=&quot;UsER&quot;&gt; select * from user&lt;/select&gt;123&lt;typeAliases&gt; &lt;package name=&quot;com.alex.pojo&quot;&gt;&lt;/package&gt;&lt;/typeAliases&gt; 映射文件中使用，定义别名的规则就是对应包装类的类名，可以忽略大小写 Mapper.xml123&lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user&lt;/select&gt; MyBatis已经为Java的常见类型默认指定了别名，可以直接使用。这里要注意的是，有一些基本数据类型和包装类数据类型的名称一样（除了包装类中首字母大写的类），故在基本数据类型的前面加上下划线“_”作为区分。 MyBatis中常见类型别名： 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 4.typeHandlers（类型处理器）在MyBatis的映射配置文件中，在使用SQL往数据库输入数据的时候最终要从Java类型转换成数据库能识别的类型，而SQL从数据库的查询结果集中获取的数据，也要从数据库的数据类型转换为对应的Java类型。在MyBatis中，使用类型处理器（TypeHandler）将从数据库获取的值以合适的方式转换为Java类型，或者将Java类型的参数转换为数据库对应的类型。在MyBatis中已经有许多自带的类型处理器，但有时候也会满足不了开发的需求，这时候就需要配置自己的类型处理器了，typeHandlers标签就是用来声明自己的类型处理器的。 MyBatis提供默认的类型处理器： 类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SMALLINT IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 BIGINT FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR 或任何兼容的字符串类型，用来存储枚举的名称（而不是索引序数值） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，用来存储枚举的序数值（而不是名称）。 SqlxmlTypeHandler java.lang.String SQLXML InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR 或 LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE 5、对象工厂（objectFactory）每次MyBatis创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。 如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。 6、插件（plugins）插件可以在映射语句执行过程中的某一点进行拦截调用，也可以通过重写方法对执行过程进行修改，可以用作日志记录、权限控制、缓存控制等。 MyBatis中的插件一定要慎用，如果使用不当回对返回结果以及执行过程产生影响，有可能会影响MyBatis的核心功能 7、环境配置（environments）MyBatis可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。 这里要注意的是尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。也就是如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，可以使用下面两种方法进行实现。 为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder即可。 SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment);SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment,properties); 把上面的代码拿下来看一下 &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 这里可以看到有有四个关键的地方 default&#x3D;”development” 指定默认的环境 id&#x3D;”development” 指定环境的id，提供给上面的方法进行构造SqlSessionFactory使用 transactionManager 事务管理器的配置 dataSource 数据源的配置 下面主要讲一下transactionManager 和 dataSource 7.1、事务管理器（transactionManager）在 MyBatis 中有两种类型的事务管理器（也就是 type&#x3D;”[JDBC|MANAGED]”）： JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务范围。 MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。比如下面: &lt;transactionManager type=&quot;MANAGED&quot;&gt; &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt; 后期一般会使用Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 7.2、数据源（dataSource）dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源,有三种内建的数据源类型（也就是 type&#x3D;”[UNPOOLED|POOLED|JNDI]”）：（1）UNPOOLED这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性： driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为”driver.”，例如：driver.encoding&#x3D;UTF8 （2）POOLED这种数据源的实现利用”池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。除了上述提到 UNPOOLED 下的属性外，会有更多属性用来配置 POOLED 的数据源： poolMaximumActiveConnections – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒） poolTimeToWait – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。 poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是”NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。 poolPingEnabled – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 poolPingQuery 属性（最好是一个非常快的 SQL），默认值：false。 poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。 8、数据库厂商标识（databaseIdProvider）可以让Mybatis通过不同的数据库厂商执行不同的语句，具体配置方法如下1、在主配置文件中加入数据库厂商标识 1234&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt; &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;&lt;/databaseIdProvider&gt; 在上面的配置中有两个点比较关键（1）databaseIdProvider标签的type属性的DB_VENDOR,这个是MyBatis中默认的别名，对应org.apache.ibatis.mapping.VendorDatabaseIdProvider类,这个类将会从数据源获取的连接中获取数据源对应数据库的产品名（connection.getMetaData().getDatabaseProductName()）设置成对应的databaseId,当然也可以实现org.apache.ibatis.mapping.DatabaseIdProvider类进行配置（2）从上面获取的databaseId可能会很长，在后期的配置中可能会很麻烦于是就通过property设置属性别名来使其变短2、在Mapper映射文件中配置不同的数据源对应的SQL语句 123456789&lt;select id=&quot;getTime&quot; resultType=&quot;string&quot; databaseId=&quot;mysql&quot;&gt; select now() from dual&lt;/select&gt;&lt;select id=&quot;getTime&quot; resultType=&quot;string&quot;&gt; select now() from dual&lt;/select&gt;&lt;select id=&quot;getTime&quot; resultType=&quot;string&quot; databaseId=&quot;oracle&quot;&gt; select &#x27;oralce&#x27;||to_char(sysdate,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) from dual&lt;/select&gt; 比如在使用getTime时，在environments的dataSource中获取的数据源时Mysql的情况下，MyBatis会加载databaseId为mysql的语句，oracle同理，如果没用进行配置的时候会加载没有配置databaseId的语句。databaseIdProvider、databaseId以及environment的结合可以实现多数据库多厂商的配置。 9、映射器（mappers）按照顺序配置好各项参数后，MyBatis的运行环境相关配置基本已经差不多了，现在就需要告诉MyBatis去哪边找到SQL语句，这个时候Mappers就相当于引路人可以通过提供相对于类路径的资源引用， 或完全限定资源定位符或类名和包名等告诉MyBatis去找各个映射然后从映射中取出对应的SQL语句。所以有下面四种常见的方式来配置mappers。 1、使用映射文件的相对路径进行配置12345&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 2、使用接口全类名的方式进行配置12345&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.mappers.UserMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.mappers.ProductMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.mappers.ManagerMapper&quot;/&gt;&lt;/mappers&gt; 3、使用包名进行配置123&lt;mappers&gt; &lt;package name=&quot;org.mybatis.mappers&quot;/&gt;&lt;/mappers&gt; 4、使用文件系统绝对路径进行配置12345&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/UserMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/ProductMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/ManagerMapper.xml&quot;/&gt;&lt;/mappers&gt; 在日常使用中经常使用前3种方式进行配置，在配置中需要注意在配置标签中属性的名称，主要分url、resource、class、name： package中只有一个属性，就是包名name mapper中使用url后面跟的就是全地址 mapper中使用resource的就是相对地址 mapper中使用class的就是对应的接口全类名 在主配置有很多属性保持默认即可，有特殊需求时再做配置，需要重点关注的是setting和environments，这两个在Mybatis的生命周期中有着很重要的影响，如果配置不合理可能会影响整个框架的运行，结束了枯燥的主配置文件，下面就开始介绍一下SQL的载体Mapper配置文件。 三、MyBatis的Mapper映射文件相比于主配置文件，Mapper文件把更多的权力交给了开发者，用简单的功能实现强大的功能，他的顶层结构如下： cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句在上面只是写了一个很简单的UserMapper.xml，在实际上使用中，一个Mapper文件大致长这个样子UserMapper.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;User&quot;&gt; &lt;!-- 用户信息ResultMap --&gt; &lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.alex.pojo.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.alex.pojo.User&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据用户编号，查询单个用户实体 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 新增用户 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.alex.pojo.User&quot;&gt; INSERT INTO user(username,password,birthday) VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;!-- 修改用户 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.alex.pojo.User&quot;&gt; UPDATE user SET username = #&#123;username&#125; ,password=#&#123;password&#125; ,birthday=#&#123;birthday&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt; DELETE FROM user WHERE id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 1、insert、delete、update及select标签的属性上面代码中介绍了整个对用户的增删改查，分别使用insert、delete、update及select标签，下面就先来看一下标签中的属性： 123456789101112131415161718192021222324252627282930313233343536 &lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; parameterMap=&quot;deprecated&quot; resultType=&quot;hashmap&quot; resultMap=&quot;personResultMap&quot; flushCache=&quot;false&quot; useCache=&quot;true&quot; timeout=&quot;10&quot; fetchSize=&quot;256&quot; statementType=&quot;PREPARED&quot; resultSetType=&quot;FORWARD_ONLY&quot;&gt;&lt;insert id=&quot;insertAuthor&quot; parameterType=&quot;domain.blog.Author&quot; flushCache=&quot;true&quot; statementType=&quot;PREPARED&quot; keyProperty=&quot;&quot; keyColumn=&quot;&quot; useGeneratedKeys=&quot;&quot; timeout=&quot;20&quot;&gt;&lt;update id=&quot;updateAuthor&quot; parameterType=&quot;domain.blog.Author&quot; flushCache=&quot;true&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt;&lt;delete id=&quot;deleteAuthor&quot; parameterType=&quot;domain.blog.Author&quot; flushCache=&quot;true&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt; 属性名 对应含义 id SQL映射配置的唯一标识，可以代表SQL配置。 parameterType 可选属性，用来传入SQL配置中需要的参数类型的类名或别名。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。 flushCache 设置语句调用时，是否清空本地缓存和二级缓存，默认为false。 useCache 设置语句调用时，执行结果是否保存二级缓存，对select元素默认为false。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。 fetchSize 设置驱动程序每次批量返回结果的行数。 statementType 设置MyBatis的statement类型。可以配置为STATEMENT，PREPARED 或 CALLABLE 中的一个，表示使用Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType 设置MyBatis的结果集类型。可以配置为FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。 databaseId 在配置databaseIdProvider（数据库厂商标识）的情况下，MyBatis会加载所有不带databaseId或者匹配当前databaseId的语句。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 当有多个结果集的时候使用，会为SQL执行后返回的每个结果集设定一个名称，以逗号分隔。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。 该表整理自MyBatis的官网，其中很多的词汇很生疏很难懂，在大部分日常中保持默认值即可，在特殊的时候需要去了解更多关于JDBC相关的知识，本文暂时不做论述，下面就是需要介绍一下在基础增删改查中出现的最重要的两个地方————Mapper配置输入映射和Mapper配置输出映射。 2、Mapper配置输入映射在增删改查中，往往少不了参数的传递有许多SQL配置是需要传递参数的。在MyBatis的SQL映射配置文件Mapper.xml中，输入参数属性配置在parameterType中。对于parameterType属性，可以配置的基本数据类型有：int、double、float、short、long、byte、char、boolean，基本数据包装类有：Byte、Short、Integer、Long、Float、Double、Boolean、Character，还有Java复杂数据类型JavaBean（String）或其他自定义的实体类，同时也可以配为类对应类型别名。 3、Mapper配置输出映射在MyBatis的Mapper映射文件中，SQL语句查询后返回的结果，会映射到配置标签的输出映射属性对应的Java类型。Mapper的输出映射有两种配置，分别是resultType和resultMap。 3.1、resultTyperesultType除了像parameter一样支持基本数据类型、基本数据包装类之外，也支持自定义实体类。 如果从数据库查询出来的列名与实体类中的属性名全都不一致，则不会创建实体类对象，如果数据库查询出来的列名与实体类的属性名至少有一个一致，那么就会创建实体类对象。 3.2、resultMap如果我们SQL查询出的内容和创建的实体类没有一个字段是相同的，但是又想把数据填充到对应的字段中，这个时候MyBatis提供了一种SQL结果集输出映射类型————resultMap，可以通过定义一个resultMap在列名和Java包装类属性名之间创建映射关系。 1234567891011&lt;!--定义一个resultMap--&gt;&lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.alex.pojo.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;&lt;/resultMap&gt;&lt;!-- 使用resultMap调用id为userResultMap进行封装--&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; 使用id为“userResultMap”的resultMap配置将select查询语句和User类中的属性进行映射。id属性是resultMap的唯一标识，而type是最终所映射的Java对象类型，可以使用别名。在resultMap标签对中，id标签指的是查询结果集中的唯一标识（比如User的唯一标识就是id），result标签指的是普通列的定义（User类中的其他非主键属性），其column指的是SQL语句查询出的列名，然后对应的property是type所指定的Java实体类中的属性名，最终resultMap会对column和property进行映射（对应关系），这样最终就会拿到一个填充了查询结果的User类。 如果resultMap在其他的Mapper配置文件中，则需要在id前面加上那个Mapper配置文件的namespace即可。 四、最终的CRUD上面对MyBatis进行的基本的配置，简单配置之后就可以让MyBatis跑起来了，对于JAVA程序而言主要是分为四部1、获取主配置文件的IO流2、通过配置文件获取对应SqlSessionFactory3、通过SqlSessionFactory获取一个SqlSession4、通过SqlSession进行CRUD 对初体验的代码进行改进，加上增删改的方法123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) throws IOException &#123; String resource = &quot;mybatis-config.xml&quot;; //1、获取主配置文件的IO流 InputStream inputStream = Resources.getResourceAsStream(resource); //2、通过配置文件获取对应SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //3、通过SqlSessionFactory获取一个SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; list = sqlSession.selectList(&quot;User.findAll&quot;); for (User user : list) &#123; System.out.println(user); &#125; System.out.println(&quot;---------------------&quot;); User oneUser = sqlSession.selectOne(&quot;User.findUserById&quot;, 1); System.out.println(oneUser); System.out.println(&quot;---------------------&quot;); User userInfo = new User(); userInfo.setUsername(&quot;lalala&quot;); userInfo.setPassword(&quot;123456&quot;); userInfo.setBirthday(&quot;2022-05-01&quot;); sqlSession.insert(&quot;User.insertUser&quot;,userInfo); list = sqlSession.selectList(&quot;User.findAll&quot;); for (User user : list) &#123; System.out.println(user); &#125; System.out.println(&quot;---------------------&quot;); oneUser.setUsername(&quot;657657&quot;); sqlSession.update(&quot;User.updateUser&quot;,oneUser); list = sqlSession.selectList(&quot;User.findAll&quot;); for (User user : list) &#123; System.out.println(user); &#125; System.out.println(&quot;---------------------&quot;); sqlSession.delete(&quot;User.deleteUser&quot;,2); list = sqlSession.selectList(&quot;User.findAll&quot;); for (User user : list) &#123; System.out.println(user); &#125;&#125; 这里一定要注意，因为是Demo的代码我写在main函数中，这边没有对数据进行提交的回滚以及对sqlSession资源的释放，如果真实使用请使用try catch包裹对事务进行提交以及资源释放 运行结果 通过上面的例子可以看出sqlSession对于CRUD主要提供了五个方法，第一个参数都为statementId(Mapper文件的namespace+对应映射语句的id)，后面的跟对应的参数，这样好像相对于JDBC来说只是不用我们去写结果集和实体类的映射，但是与之带来的是更多的配置，其实不然，本文中目前仅仅只是介绍了MyBatis最基本的使用，通过上面的代码进行简单的配置，已经可以进行数据库的访问，MyBatis除了基础的数据库访问和结果集映射还有很多高级用法，具体又有哪些高阶用法请看XXXXXX。","categories":[{"name":"分类6","slug":"分类6","permalink":"https://it65720.top/categories/%E5%88%86%E7%B1%BB6/"}],"tags":[{"name":"测试11","slug":"测试11","permalink":"https://it65720.top/tags/%E6%B5%8B%E8%AF%9511/"},{"name":"测试10","slug":"测试10","permalink":"https://it65720.top/tags/%E6%B5%8B%E8%AF%9510/"}]}],"categories":[{"name":"分类6","slug":"分类6","permalink":"https://it65720.top/categories/%E5%88%86%E7%B1%BB6/"}],"tags":[{"name":"测试11","slug":"测试11","permalink":"https://it65720.top/tags/%E6%B5%8B%E8%AF%9511/"},{"name":"测试10","slug":"测试10","permalink":"https://it65720.top/tags/%E6%B5%8B%E8%AF%9510/"}]}